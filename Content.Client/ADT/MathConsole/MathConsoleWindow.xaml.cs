using Content.Shared.ADT.MathConsole;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Client.Stylesheets;
using Robust.Client.Graphics;

using System;
using System.Collections.Generic;
using System.Linq;
using Robust.Shared.Input;
using System.Text.RegularExpressions;
using System.Numerics;
using Robust.Shared.Maths;

namespace Content.Client.ADT.MathConsole;

// –ö–∞—Å—Ç–æ–º–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–æ–π —Å–µ—Ç–∫–∏
public class CoordinateGridControl : Control
{
    private const int GridSize = 21;
    private const int CellSize = 20;
    private List<(int x, int y, string label)> points = new();
    private string currentEquation = "";
    private bool showLines = false;

    public void SetEquation(string equation)
    {
        currentEquation = equation;
        ExtractPointsFromEquation(equation);
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ª–∏–Ω–∏–∏ –¥–ª—è –∑–∞–¥–∞—á —Å –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏
        showLines = points.Count == 2;
        InvalidateMeasure();
    }

    public void AddPoint(int x, int y, string label)
    {
        points.Add((x, y, label));
        InvalidateMeasure();
    }

    public void ClearPoints()
    {
        points.Clear();
        InvalidateMeasure();
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        return new Vector2(GridSize * CellSize, GridSize * CellSize);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        var size = Size;
        var centerX = size.X / 2;
        var centerY = size.Y / 2;

        // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
        for (int i = 0; i <= GridSize; i++)
        {
            var pos = i * CellSize;

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            if (i == GridSize / 2) // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è Y
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, size.Y), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, size.Y), Color.Gray);
            }

            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            if (i == GridSize / 2) // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è X
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(size.X, pos), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(size.X, pos), Color.Gray);
            }
        }

        // –†–∏—Å—É–µ–º –ª–∏–Ω–∏–∏ –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å –¥–≤–µ —Ç–æ—á–∫–∏)
        if (showLines && points.Count == 2)
        {
            var point1 = points[0];
            var point2 = points[1];

            var gridX1 = (point1.x + GridSize / 2) * CellSize;
            var gridY1 = (GridSize / 2 - point1.y) * CellSize;
            var gridX2 = (point2.x + GridSize / 2) * CellSize;
            var gridY2 = (GridSize / 2 - point2.y) * CellSize;

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º –ö–æ—ç–Ω–∞-–°–∞–∑–µ—Ä–ª–µ–Ω–¥–∞ –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ª–∏–Ω–∏–∏
            var startPoint = new Vector2(gridX1, gridY1);
            var endPoint = new Vector2(gridX2, gridY2);

            var clippedStart = ClipLineToBounds(startPoint, endPoint, size);
            var clippedEnd = ClipLineToBounds(endPoint, startPoint, size);

            if (clippedStart.HasValue && clippedEnd.HasValue)
            {
                handle.DrawLine(clippedStart.Value, clippedEnd.Value, new Color(224, 102, 255)); // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            }
        }

        // –†–∏—Å—É–µ–º —Ç–æ—á–∫–∏
        foreach (var point in points)
        {
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–∫–∏ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞
            // –¶–µ–Ω—Ç—Ä —Å–µ—Ç–∫–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ (GridSize/2, GridSize/2)
            var gridX = (point.x + GridSize / 2) * CellSize;
            var gridY = (GridSize / 2 - point.y) * CellSize; // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Y –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏

            if (gridX >= 0 && gridX < size.X && gridY >= 0 && gridY < size.Y)
            {
                // –†–∏—Å—É–µ–º –∫—Ä—É–≥ –¥–ª—è —Ç–æ—á–∫–∏
                handle.DrawCircle(new Vector2(gridX, gridY), 4, new Color(224, 102, 255)); // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            }
        }
    }

    private Vector2? ClipLineToBounds(Vector2 start, Vector2 end, Vector2 bounds)
    {
        // –ê–ª–≥–æ—Ä–∏—Ç–º –ö–æ—ç–Ω–∞-–°–∞–∑–µ—Ä–ª–µ–Ω–¥–∞ –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ª–∏–Ω–∏–π
        var x1 = start.X;
        var y1 = start.Y;
        var x2 = end.X;
        var y2 = end.Y;

        // –ö–æ–¥—ã –æ–±–ª–∞—Å—Ç–µ–π
        var code1 = GetRegionCode(x1, y1, bounds);
        var code2 = GetRegionCode(x2, y2, bounds);

        var accept = false;

        while (true)
        {
            if ((code1 | code2) == 0)
            {
                // –û–±–µ —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ - –ø—Ä–∏–Ω–∏–º–∞–µ–º
                accept = true;
                break;
            }
            else if ((code1 & code2) != 0)
            {
                // –û–±–µ —Ç–æ—á–∫–∏ —Å–Ω–∞—Ä—É–∂–∏ –≤ –æ–¥–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ - –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º
                break;
            }
            else
            {
                // –í—ã–±–∏—Ä–∞–µ–º —Ç–æ—á–∫—É —Å–Ω–∞—Ä—É–∂–∏
                var codeOut = code1 != 0 ? code1 : code2;
                double x, y;

                // –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                if ((codeOut & 1) != 0) // –°–ª–µ–≤–∞
                {
                    x = 0;
                    y = y1 + (y2 - y1) * (0 - x1) / (x2 - x1);
                }
                else if ((codeOut & 2) != 0) // –°–ø—Ä–∞–≤–∞
                {
                    x = bounds.X;
                    y = y1 + (y2 - y1) * (bounds.X - x1) / (x2 - x1);
                }
                else if ((codeOut & 4) != 0) // –°–Ω–∏–∑—É
                {
                    y = 0;
                    x = x1 + (x2 - x1) * (0 - y1) / (y2 - y1);
                }
                else // –°–≤–µ—Ä—Ö—É
                {
                    y = bounds.Y;
                    x = x1 + (x2 - x1) * (bounds.Y - y1) / (y2 - y1);
                }

                // –ó–∞–º–µ–Ω—è–µ–º –≤–Ω–µ—à–Ω—é—é —Ç–æ—á–∫—É
                if (codeOut == code1)
                {
                    x1 = (float)x;
                    y1 = (float)y;
                    code1 = GetRegionCode(x1, y1, bounds);
                }
                else
                {
                    x2 = (float)x;
                    y2 = (float)y;
                    code2 = GetRegionCode(x2, y2, bounds);
                }
            }
        }

        if (accept)
        {
            return new Vector2((float)x1, (float)y1);
        }

        return null;
    }

    private int GetRegionCode(double x, double y, Vector2 bounds)
    {
        var code = 0;
        if (x < 0) code |= 1;      // –°–ª–µ–≤–∞
        if (x > bounds.X) code |= 2; // –°–ø—Ä–∞–≤–∞
        if (y < 0) code |= 4;      // –°–Ω–∏–∑—É
        if (y > bounds.Y) code |= 8; // –°–≤–µ—Ä—Ö—É
        return code;
    }

    private void ExtractPointsFromEquation(string equation)
    {
        points.Clear();

        // –ò—â–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö
        var patterns = new[]
        {
            @"A\((-?\d+),\s*(-?\d+)\)",
            @"B\((-?\d+),\s*(-?\d+)\)",
            @"—Ç–æ—á–∫–∞\s+A\((-?\d+),\s*(-?\d+)\)",
            @"—Ç–æ—á–∫–∞\s+B\((-?\d+),\s*(-?\d+)\)",
            @"–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã\s+A\((-?\d+),\s*(-?\d+)\)",
            @"–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã\s+B\((-?\d+),\s*(-?\d+)\)",
            @"—Ç–æ—á–∫–∞–º–∏\s+A\((-?\d+),\s*(-?\d+)\)",
            @"—Ç–æ—á–∫–∞–º–∏\s+B\((-?\d+),\s*(-?\d+)\)"
        };
        var labels = new[] { "A", "B", "A", "B", "A", "B", "A", "B" };

        for (int i = 0; i < patterns.Length; i++)
        {
            var match = Regex.Match(equation, patterns[i]);
            if (match.Success)
            {
                var x = int.Parse(match.Groups[1].Value);
                var y = int.Parse(match.Groups[2].Value);
                points.Add((x, y, labels[i]));
            }
        }
    }
}

public partial class MathConsoleWindow : FancyWindow
{
    private Label CurrentEquationText;
    private LineEdit AnswerInput;
    private Button SubmitButton;
    private Button NewEquationButton;
    private BoxContainer RecordsList;
    private PanelContainer CoordinateGridContainer;
    private CoordinateGridControl CoordinateGrid;
    private Label TotalPointsLabel;

    // –ù–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã UI
    private Label EquationsSolvedLabel;
    private Label AccuracyRateLabel;
    private Label AverageTimeLabel;
    private Label DifficultyLevelLabel;
    private BoxContainer AchievementsList;

    public event Action<string>? SubmitAnswer;
    public event Action? RequestNewEquation;
    public event Action? OnClose;

    public MathConsoleWindow()
    {
        InitializeComponent();

        CurrentEquationText = this.FindControl<Label>("CurrentEquationText");
        AnswerInput = this.FindControl<LineEdit>("AnswerInput");
        SubmitButton = this.FindControl<Button>("SubmitButton");
        NewEquationButton = this.FindControl<Button>("NewEquationButton");
        RecordsList = this.FindControl<BoxContainer>("RecordsList");
        CoordinateGridContainer = this.FindControl<PanelContainer>("CoordinateGridContainer");
        CoordinateGrid = this.FindControl<CoordinateGridControl>("CoordinateGrid");
        TotalPointsLabel = this.FindControl<Label>("TotalPointsLabel");

        // –ù–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        EquationsSolvedLabel = this.FindControl<Label>("EquationsSolvedLabel");
        AccuracyRateLabel = this.FindControl<Label>("AccuracyRateLabel");
        AverageTimeLabel = this.FindControl<Label>("AverageTimeLabel");
        DifficultyLevelLabel = this.FindControl<Label>("DifficultyLevelLabel");
        AchievementsList = this.FindControl<BoxContainer>("AchievementsList");

        // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è
        SubmitButton.OnPressed += OnSubmitButtonClick;
        NewEquationButton.OnPressed += OnNewEquationButtonClick;
        AnswerInput.OnTextEntered += OnAnswerInputKeyDown;

        // –§–æ–∫—É—Å –Ω–∞ –ø–æ–ª–µ –≤–≤–æ–¥–∞
        AnswerInput.GrabKeyboardFocus();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        InitializeAchievements();
    }

    private void InitializeComponent()
    {
        RobustXamlLoader.Load(this);
    }

    private void OnSubmitButtonClick(BaseButton.ButtonEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void OnNewEquationButtonClick(BaseButton.ButtonEventArgs e)
    {
        RequestNewEquation?.Invoke();
        AnswerInput.Text = string.Empty;
        AnswerInput.GrabKeyboardFocus();
    }

    private void OnAnswerInputKeyDown(LineEdit.LineEditEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void SubmitAnswerInternal()
    {
        var answer = AnswerInput.Text?.Trim();
        if (!string.IsNullOrEmpty(answer))
        {
            SubmitAnswer?.Invoke(answer);
            AnswerInput.Text = string.Empty;
            AnswerInput.GrabKeyboardFocus();
        }
    }

    public void UpdateState(MathConsoleState state)
    {
        CurrentEquationText.Text = state.CurrentEquation;
        TotalPointsLabel.Text = state.TotalPointsEarned.ToString();

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        UpdateStatistics(state.Records);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω—É—é —Å–µ—Ç–∫—É
        ShowCoordinateGridIfNeeded(state.CurrentEquation);

        RecordsList.RemoveAllChildren();
        foreach (var record in state.Records.OrderByDescending(r => r.SolvedAt))
        {
            var recordPanel = new PanelContainer();
            recordPanel.PanelOverride = new StyleBoxFlat { BackgroundColor = new Color(0, 0, 0, 0.3f) };

            var recordBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Vertical, Margin = new Thickness(5) };

            // –£—Ä–∞–≤–Ω–µ–Ω–∏–µ
            var equationLabel = new Label
            {
                Text = record.Equation,
                FontColorOverride = Color.White,
                HorizontalExpand = true
            };
            recordBox.AddChild(equationLabel);

            // –û—Ç–≤–µ—Ç –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            var infoBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal, HorizontalExpand = true };
            infoBox.AddChild(new Label { Text = $"–û—Ç–≤–µ—Ç: {record.Answer}", FontColorOverride = new Color(224, 102, 255) });
            infoBox.AddChild(new Label { Text = $"–ò–≥—Ä–æ–∫: {record.EntityName}", FontColorOverride = new Color(224, 102, 255), HorizontalExpand = true });
            infoBox.AddChild(new Label { Text = $"+{record.PointsEarned} –æ—á–∫–æ–≤", FontColorOverride = new Color(224, 102, 255) });

            recordBox.AddChild(infoBox);
            recordPanel.AddChild(recordBox);

            RecordsList.AddChild(recordPanel);
        }
    }

    private void UpdateStatistics(List<MathConsoleRecord> records)
    {
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—à–µ–Ω–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π
        EquationsSolvedLabel.Text = records.Count.ToString();

        // –¢–æ—á–Ω–æ—Å—Ç—å (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ 100% –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
        var accuracy = records.Count > 0 ? 100 : 0;
        AccuracyRateLabel.Text = $"{accuracy}%";

        // –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ "0s" –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
        AverageTimeLabel.Text = "0s";

        // –£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
        var totalPoints = records.Sum(r => r.PointsEarned);
        var difficulty = totalPoints switch
        {
            < 50 => "–ù–æ–≤–∏—á–æ–∫",
            < 150 => "–£—á–µ–Ω–∏–∫",
            < 300 => "–°—Ç—É–¥–µ–Ω—Ç",
            < 500 => "–ú–∞–≥–∏—Å—Ç—Ä",
            _ => "–ü—Ä–æ—Ñ–µ—Å—Å–æ—Ä"
        };
        DifficultyLevelLabel.Text = difficulty;
    }

    private void InitializeAchievements()
    {
        AchievementsList.RemoveAllChildren();

        // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        var achievements = new[]
        {
            ("üèÜ –ú–∞—Å—Ç–µ—Ä –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏", "–†–µ—à–∏—Ç–µ 50 —É—Ä–∞–≤–Ω–µ–Ω–∏–π", false),
            ("‚ö° –ë—ã—Å—Ç—Ä—ã–π —Ä–µ—à–∞—Ç–µ–ª—å", "–†–µ—à–∏—Ç–µ 10 —É—Ä–∞–≤–Ω–µ–Ω–∏–π –∑–∞ 5 –º–∏–Ω—É—Ç", false),
            ("üìê –≠–∫—Å–ø–µ—Ä—Ç –≥–µ–æ–º–µ—Ç—Ä–∏–∏", "–†–µ—à–∏—Ç–µ 20 –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á", false),
            ("üßÆ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä", "–†–µ—à–∏—Ç–µ 100 —É—Ä–∞–≤–Ω–µ–Ω–∏–π", false),
            ("üéØ –¢–æ—á–Ω–æ—Å—Ç—å", "–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 95% —Ç–æ—á–Ω–æ—Å—Ç–∏", false)
        };

        foreach (var (name, description, unlocked) in achievements)
        {
            var achievementPanel = new PanelContainer();
            achievementPanel.PanelOverride = new StyleBoxFlat
            {
                BackgroundColor = unlocked ? new Color(218, 112, 214, 0.2f) : new Color(0, 0, 0, 0.3f)
            };

            var achievementBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Vertical, Margin = new Thickness(5) };

            var nameLabel = new Label
            {
                Text = name,
                FontColorOverride = unlocked ? new Color(218, 112, 214) : new Color(128, 128, 128),
                HorizontalExpand = true
            };
            achievementBox.AddChild(nameLabel);

            var descLabel = new Label
            {
                Text = description,
                FontColorOverride = unlocked ? new Color(218, 112, 214) : new Color(100, 100, 100),
                HorizontalExpand = true
            };
            achievementBox.AddChild(descLabel);

            achievementPanel.AddChild(achievementBox);
            AchievementsList.AddChild(achievementPanel);
        }
    }

    private void ShowCoordinateGridIfNeeded(string equation)
    {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω—É—é —Å–µ—Ç–∫—É –¥–ª—è –∑–∞–¥–∞—á —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–µ–π
        var isCoordinateTask = equation.Contains("—Ç–æ—á–∫–∞–º–∏") ||
                              equation.Contains("—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ") ||
                              equation.Contains("—Å–µ—Ä–µ–¥–∏–Ω—É") ||
                              equation.Contains("—É–≥–ª–æ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç") ||
                              equation.Contains("–≥—Ä–∞—Ñ–∏–∫") ||
                              equation.Contains("–ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è") ||
                              equation.Contains("–æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å") ||
                              equation.Contains("–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã");

        if (isCoordinateTask)
        {
            CoordinateGridContainer.Visible = true;
            CoordinateGrid.SetEquation(equation);
        }
        else
        {
            CoordinateGridContainer.Visible = false;
        }
    }

    public override void Close()
    {
        OnClose?.Invoke();
        base.Close();
    }
}
