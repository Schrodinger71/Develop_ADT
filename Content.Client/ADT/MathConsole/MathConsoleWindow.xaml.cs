using Content.Shared.ADT.MathConsole;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Client.Stylesheets;
using Robust.Client.Graphics;

using System;
using System.Collections.Generic;
using System.Linq;
using Robust.Shared.Input;
using System.Text.RegularExpressions;
using System.Numerics;
using Robust.Shared.Maths;

namespace Content.Client.ADT.MathConsole;

// Кастомный элемент для отрисовки координатной сетки
public class CoordinateGridControl : Control
{
    private const int GridSize = 21;
    private const int CellSize = 20;
    private List<(int x, int y, string label)> points = new();
    private string currentEquation = "";
    private bool showLines = false;

    public void SetEquation(string equation)
    {
        currentEquation = equation;
        ExtractPointsFromEquation(equation);
        showLines = points.Count == 2;
        InvalidateMeasure();
    }

    public void AddPoint(int x, int y, string label)
    {
        points.Add((x, y, label));
        InvalidateMeasure();
    }

    public void ClearPoints()
    {
        points.Clear();
        InvalidateMeasure();
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        var maxSize = Math.Min(availableSize.X, availableSize.Y);
        var gridSize = Math.Min(maxSize, GridSize * CellSize);
        return new Vector2(gridSize, gridSize);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        var size = Size;
        var gridSize = Math.Min(size.X, size.Y);
        var cellSize = gridSize / GridSize;

        // Рисуем сетку
        for (int i = 0; i <= GridSize; i++)
        {
            var pos = i * cellSize;

            // Вертикальные линии
            if (i == GridSize / 2)
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, gridSize), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, gridSize), Color.Gray);
            }

            // Горизонтальные линии
            if (i == GridSize / 2)
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(gridSize, pos), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(gridSize, pos), Color.Gray);
            }
        }

        // Рисуем линии между точками
        if (showLines && points.Count == 2)
        {
            var point1 = points[0];
            var point2 = points[1];

            var gridX1 = (point1.x + GridSize / 2) * cellSize;
            var gridY1 = (GridSize / 2 - point1.y) * cellSize;
            var gridX2 = (point2.x + GridSize / 2) * cellSize;
            var gridY2 = (GridSize / 2 - point2.y) * cellSize;

            var startPoint = new Vector2(gridX1, gridY1);
            var endPoint = new Vector2(gridX2, gridY2);

            var clippedStart = ClipLineToBounds(startPoint, endPoint, new Vector2(gridSize, gridSize));
            var clippedEnd = ClipLineToBounds(endPoint, startPoint, new Vector2(gridSize, gridSize));

            if (clippedStart.HasValue && clippedEnd.HasValue)
            {
                handle.DrawLine(clippedStart.Value, clippedEnd.Value, new Color(224, 102, 255));
            }
        }

        // Рисуем точки
        for (int i = 0; i < points.Count; i++)
        {
            var point = points[i];
            var gridX = (point.x + GridSize / 2) * cellSize;
            var gridY = (GridSize / 2 - point.y) * cellSize;

            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize)
            {
                handle.DrawCircle(new Vector2(gridX, gridY), 4, new Color(224, 102, 255));
            }
        }
    }

    private Vector2? ClipLineToBounds(Vector2 start, Vector2 end, Vector2 bounds)
    {
        var x1 = start.X;
        var y1 = start.Y;
        var x2 = end.X;
        var y2 = end.Y;

        var code1 = GetRegionCode(x1, y1, bounds);
        var code2 = GetRegionCode(x2, y2, bounds);

        var accept = false;

        while (true)
        {
            if ((code1 | code2) == 0)
            {
                accept = true;
                break;
            }
            else if ((code1 & code2) != 0)
            {
                break;
            }
            else
            {
                var codeOut = code1 != 0 ? code1 : code2;
                double x, y;

                if ((codeOut & 1) != 0)
                {
                    x = 0;
                    y = y1 + (y2 - y1) * (0 - x1) / (x2 - x1);
                }
                else if ((codeOut & 2) != 0)
                {
                    x = bounds.X;
                    y = y1 + (y2 - y1) * (bounds.X - x1) / (x2 - x1);
                }
                else if ((codeOut & 4) != 0)
                {
                    y = 0;
                    x = x1 + (x2 - x1) * (0 - y1) / (y2 - y1);
                }
                else
                {
                    y = bounds.Y;
                    x = x1 + (x2 - x1) * (bounds.Y - y1) / (y2 - y1);
                }

                if (codeOut == code1)
                {
                    x1 = (float)x;
                    y1 = (float)y;
                    code1 = GetRegionCode(x1, y1, bounds);
                }
                else
                {
                    x2 = (float)x;
                    y2 = (float)y;
                    code2 = GetRegionCode(x2, y2, bounds);
                }
            }
        }

        if (accept)
        {
            return new Vector2((float)x1, (float)y1);
        }

        return null;
    }

    private int GetRegionCode(double x, double y, Vector2 bounds)
    {
        var code = 0;
        if (x < 0) code |= 1;
        if (x > bounds.X) code |= 2;
        if (y < 0) code |= 4;
        if (y > bounds.Y) code |= 8;
        return code;
    }

    private void ExtractPointsFromEquation(string equation)
    {
        points.Clear();

        var patterns = new[]
        {
            @"A\((-?\d+),\s*(-?\d+)\)",
            @"B\((-?\d+),\s*(-?\d+)\)",
            @"точка\s+A\((-?\d+),\s*(-?\d+)\)",
            @"точка\s+B\((-?\d+),\s*(-?\d+)\)",
            @"координаты\s+A\((-?\d+),\s*(-?\d+)\)",
            @"координаты\s+B\((-?\d+),\s*(-?\d+)\)",
            @"точками\s+A\((-?\d+),\s*(-?\d+)\)",
            @"точками\s+B\((-?\d+),\s*(-?\d+)\)"
        };
        var labels = new[] { "A", "B", "A", "B", "A", "B", "A", "B" };

        for (int i = 0; i < patterns.Length; i++)
        {
            var match = Regex.Match(equation, patterns[i]);
            if (match.Success)
            {
                var x = int.Parse(match.Groups[1].Value);
                var y = int.Parse(match.Groups[2].Value);
                points.Add((x, y, labels[i]));
            }
        }
    }
}

public partial class MathConsoleWindow : FancyWindow
{
    private Label CurrentEquationText;
    private LineEdit AnswerInput;
    private Button SubmitButton;
    private Button NewEquationButton;
    private BoxContainer RecordsList;
    private PanelContainer CoordinateGridContainer;
    private CoordinateGridControl CoordinateGrid;
    private Label TotalPointsLabel;
    private Label CalculatorResult;

    private Label EquationsSolvedLabel;
    private Label AccuracyRateLabel;
    private Label AverageTimeLabel;
    private Label DifficultyLevelLabel;

    private string currentCalculation = "";
    private double currentResult = 0;

    public event Action<string>? SubmitAnswer;
    public event Action? RequestNewEquation;
    public event Action? OnClose;

    public MathConsoleWindow()
    {
        InitializeComponent();

        CurrentEquationText = this.FindControl<Label>("CurrentEquationText");
        AnswerInput = this.FindControl<LineEdit>("AnswerInput");
        SubmitButton = this.FindControl<Button>("SubmitButton");
        NewEquationButton = this.FindControl<Button>("NewEquationButton");
        RecordsList = this.FindControl<BoxContainer>("RecordsList");
        CoordinateGridContainer = this.FindControl<PanelContainer>("CoordinateGridContainer");
        CoordinateGrid = this.FindControl<CoordinateGridControl>("CoordinateGrid");
        TotalPointsLabel = this.FindControl<Label>("TotalPointsLabel");
        CalculatorResult = this.FindControl<Label>("CalculatorResult");

        EquationsSolvedLabel = this.FindControl<Label>("EquationsSolvedLabel");
        AccuracyRateLabel = this.FindControl<Label>("AccuracyRateLabel");
        AverageTimeLabel = this.FindControl<Label>("AverageTimeLabel");
        DifficultyLevelLabel = this.FindControl<Label>("DifficultyLevelLabel");

        SubmitButton.OnPressed += OnSubmitButtonClick;
        NewEquationButton.OnPressed += OnNewEquationButtonClick;
        AnswerInput.OnTextEntered += OnAnswerInputKeyDown;

        AnswerInput.GrabKeyboardFocus();
        InitializeCalculator();
    }

    private void InitializeComponent()
    {
        RobustXamlLoader.Load(this);
    }

    private void OnSubmitButtonClick(BaseButton.ButtonEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void OnNewEquationButtonClick(BaseButton.ButtonEventArgs e)
    {
        RequestNewEquation?.Invoke();
        AnswerInput.Text = string.Empty;
        AnswerInput.GrabKeyboardFocus();
    }

    private void OnAnswerInputKeyDown(LineEdit.LineEditEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void SubmitAnswerInternal()
    {
        var answer = AnswerInput.Text?.Trim();
        if (!string.IsNullOrEmpty(answer))
        {
            SubmitAnswer?.Invoke(answer);
            AnswerInput.Text = string.Empty;
            AnswerInput.GrabKeyboardFocus();
        }
    }

    private void InitializeCalculator()
    {
        var buttons = new[] { "C", "=", "±", "√", "x²", "+", "-", "×", "÷", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "." };

        for (int i = 0; i < buttons.Length; i++)
        {
            var buttonText = buttons[i];
            var button = this.FindControl<Button>(buttonText);
            if (button != null)
            {
                if (buttonText == "C")
                {
                    button.OnPressed += OnCalculatorClear;
                }
                else if (buttonText == "=")
                {
                    button.OnPressed += OnCalculatorEquals;
                }
                else if (buttonText == "±")
                {
                    button.OnPressed += OnCalculatorPlusMinus;
                }
                else if (buttonText == "√")
                {
                    button.OnPressed += OnCalculatorSqrt;
                }
                else if (buttonText == "x²")
                {
                    button.OnPressed += OnCalculatorSquare;
                }
                else if (IsOperator(buttonText))
                {
                    button.OnPressed += OnCalculatorOperator;
                }
                else if (IsNumber(buttonText))
                {
                    button.OnPressed += OnCalculatorNumber;
                }
            }
        }
    }

    private bool IsOperator(string text)
    {
        return text == "+" || text == "-" || text == "×" || text == "÷";
    }

    private bool IsNumber(string text)
    {
        return text == "0" || text == "1" || text == "2" || text == "3" || text == "4" ||
               text == "5" || text == "6" || text == "7" || text == "8" || text == "9" || text == ".";
    }

    private void OnCalculatorNumber(BaseButton.ButtonEventArgs e)
    {
        var button = (Button)e.Button;
        if (button.Text == "." && currentCalculation.Contains("."))
            return;

        currentCalculation += button.Text;
        UpdateCalculatorDisplay();
    }

    private void OnCalculatorOperator(BaseButton.ButtonEventArgs e)
    {
        var button = (Button)e.Button;
        if (!string.IsNullOrEmpty(currentCalculation))
        {
            var lastChar = currentCalculation[currentCalculation.Length - 1];
            if (lastChar != '+' && lastChar != '-' && lastChar != '*' && lastChar != '/')
            {
                if (!string.IsNullOrEmpty(button.Text))
                {
                    var symbol = button.Text;
                    if (symbol == "×") symbol = "*";
                    else if (symbol == "÷") symbol = "/";
                    currentCalculation += symbol;
                    UpdateCalculatorDisplay();
                }
            }
        }
    }

    private void OnCalculatorEquals(BaseButton.ButtonEventArgs e)
    {
        try
        {
            if (!string.IsNullOrEmpty(currentCalculation))
            {
                var expression = currentCalculation.Replace("×", "*").Replace("÷", "/");
                var result = SimpleEvaluate(expression);
                currentResult = result;
                currentCalculation = result.ToString();
                UpdateCalculatorDisplay();
            }
        }
        catch
        {
            currentCalculation = "Error";
            UpdateCalculatorDisplay();
        }
    }

    private double SimpleEvaluate(string expression)
    {
        // Простая реализация для базовых операций без сложного парсинга
        var parts = expression.Split('+', '-', '*', '/');
        if (parts.Length != 2) return 0;

        var left = double.Parse(parts[0]);
        var right = double.Parse(parts[1]);

        if (expression.Contains("+")) return left + right;
        if (expression.Contains("-")) return left - right;
        if (expression.Contains("*")) return left * right;
        if (expression.Contains("/")) return right != 0 ? left / right : 0;

        return 0;
    }

    private void OnCalculatorClear(BaseButton.ButtonEventArgs e)
    {
        currentCalculation = "";
        currentResult = 0;
        UpdateCalculatorDisplay();
    }

    private void OnCalculatorPlusMinus(BaseButton.ButtonEventArgs e)
    {
        if (!string.IsNullOrEmpty(currentCalculation) && currentCalculation != "0")
        {
            if (currentCalculation.StartsWith("-"))
                currentCalculation = currentCalculation.Substring(1);
            else
                currentCalculation = "-" + currentCalculation;
            UpdateCalculatorDisplay();
        }
    }

    private void OnCalculatorSqrt(BaseButton.ButtonEventArgs e)
    {
        try
        {
            if (double.TryParse(currentCalculation, out var number) && number >= 0)
            {
                currentResult = Math.Sqrt(number);
                currentCalculation = currentResult.ToString();
                UpdateCalculatorDisplay();
            }
        }
        catch
        {
            currentCalculation = "Error";
            UpdateCalculatorDisplay();
        }
    }

    private void OnCalculatorSquare(BaseButton.ButtonEventArgs e)
    {
        try
        {
            if (double.TryParse(currentCalculation, out var number))
            {
                currentResult = number * number;
                currentCalculation = currentResult.ToString();
                UpdateCalculatorDisplay();
            }
        }
        catch
        {
            currentCalculation = "Error";
            UpdateCalculatorDisplay();
        }
    }

    private void UpdateCalculatorDisplay()
    {
        CalculatorResult.Text = string.IsNullOrEmpty(currentCalculation) ? "0" : currentCalculation;
    }

    public void UpdateState(MathConsoleState state)
    {
        CurrentEquationText.Text = state.CurrentEquation;
        TotalPointsLabel.Text = state.TotalPointsEarned.ToString();

        UpdateStatistics(state.Records);
        ShowCoordinateGridIfNeeded(state.CurrentEquation);

        RecordsList.RemoveAllChildren();
        var orderedRecords = state.Records.OrderByDescending(r => r.SolvedAt).ToList();
        for (int i = 0; i < orderedRecords.Count; i++)
        {
            var record = orderedRecords[i];
            var recordPanel = new PanelContainer();
            recordPanel.PanelOverride = new StyleBoxFlat { BackgroundColor = new Color(0, 0, 0, 0.3f) };

            var recordBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Vertical, Margin = new Thickness(5) };

            var equationLabel = new Label
            {
                Text = record.Equation,
                FontColorOverride = Color.White,
                HorizontalExpand = true
            };
            recordBox.AddChild(equationLabel);

            var infoBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal, HorizontalExpand = true };
            infoBox.AddChild(new Label { Text = $"Ответ: {record.Answer}", FontColorOverride = new Color(218, 112, 214) });
            infoBox.AddChild(new Label { Text = $"Игрок: {record.EntityName}", FontColorOverride = new Color(218, 112, 214), HorizontalExpand = true });
            infoBox.AddChild(new Label { Text = $"+{record.PointsEarned} очков", FontColorOverride = new Color(218, 112, 214) });

            recordBox.AddChild(infoBox);
            recordPanel.AddChild(recordBox);
            RecordsList.AddChild(recordPanel);
        }
    }

    private void UpdateStatistics(List<MathConsoleRecord> records)
    {
        EquationsSolvedLabel.Text = records.Count.ToString();

        var accuracy = records.Count > 0 ? 100 : 0;
        AccuracyRateLabel.Text = $"{accuracy}%";

        AverageTimeLabel.Text = "0s";

        var totalPoints = records.Sum(r => r.PointsEarned);
        var difficulty = totalPoints switch
        {
            < 50 => "Новичок",
            < 150 => "Ученик",
            < 300 => "Студент",
            < 500 => "Магистр",
            _ => "Профессор"
        };
        DifficultyLevelLabel.Text = difficulty;
    }

    private void ShowCoordinateGridIfNeeded(string equation)
    {
        var isCoordinateTask = equation.Contains("точками") ||
                              equation.Contains("расстояние") ||
                              equation.Contains("середину") ||
                              equation.Contains("угловой коэффициент") ||
                              equation.Contains("график") ||
                              equation.Contains("пересечения") ||
                              equation.Contains("окружность") ||
                              equation.Contains("координаты");

        if (isCoordinateTask)
        {
            CoordinateGridContainer.Visible = true;
            CoordinateGrid.SetEquation(equation);
        }
        else
        {
            CoordinateGridContainer.Visible = false;
        }
    }

    public override void Close()
    {
        OnClose?.Invoke();
        base.Close();
    }
}
