using Content.Shared.ADT.MathConsole;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Client.Stylesheets;
using Robust.Client.Graphics;

using System;
using System.Collections.Generic;
using System.Linq;
using Robust.Shared.Input;
using System.Text.RegularExpressions;
using System.Numerics;
using Robust.Shared.Maths;

namespace Content.Client.ADT.MathConsole;

// Кастомный элемент для отрисовки координатной сетки
public class CoordinateGridControl : Control
{
    private const int GridSize = 21;
    private const int CellSize = 20;
    private List<(int x, int y, string label)> points = new();
    private string currentEquation = "";
    private bool showLines = false;

    public void SetEquation(string equation)
    {
        currentEquation = equation;
        ExtractPointsFromEquation(equation);
        // Показываем линии для задач с двумя точками
        showLines = points.Count == 2;
        InvalidateMeasure();
    }

    public void AddPoint(int x, int y, string label)
    {
        points.Add((x, y, label));
        InvalidateMeasure();
    }

    public void ClearPoints()
    {
        points.Clear();
        InvalidateMeasure();
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        return new Vector2(GridSize * CellSize, GridSize * CellSize);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        var size = Size;
        var centerX = size.X / 2;
        var centerY = size.Y / 2;

        // Рисуем сетку
        for (int i = 0; i <= GridSize; i++)
        {
            var pos = i * CellSize;

            // Вертикальные линии
            if (i == GridSize / 2) // Центральная линия Y
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, size.Y), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, size.Y), Color.Gray);
            }

            // Горизонтальные линии
            if (i == GridSize / 2) // Центральная линия X
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(size.X, pos), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(size.X, pos), Color.Gray);
            }
        }

        // Рисуем линии между точками (если есть две точки)
        if (showLines && points.Count == 2)
        {
            var point1 = points[0];
            var point2 = points[1];

            var gridX1 = (point1.x + GridSize / 2) * CellSize;
            var gridY1 = (GridSize / 2 - point1.y) * CellSize;
            var gridX2 = (point2.x + GridSize / 2) * CellSize;
            var gridY2 = (GridSize / 2 - point2.y) * CellSize;

            // Используем алгоритм Коэна-Сазерленда для обрезки линии
            var startPoint = new Vector2(gridX1, gridY1);
            var endPoint = new Vector2(gridX2, gridY2);

            var clippedStart = ClipLineToBounds(startPoint, endPoint, size);
            var clippedEnd = ClipLineToBounds(endPoint, startPoint, size);

            if (clippedStart.HasValue && clippedEnd.HasValue)
            {
                handle.DrawLine(clippedStart.Value, clippedEnd.Value, Color.Blue);
            }
        }

        // Рисуем точки
        foreach (var point in points)
        {
            // Преобразуем координаты точки в координаты экрана
            // Центр сетки находится в (GridSize/2, GridSize/2)
            var gridX = (point.x + GridSize / 2) * CellSize;
            var gridY = (GridSize / 2 - point.y) * CellSize; // Инвертируем Y для правильной ориентации

            if (gridX >= 0 && gridX < size.X && gridY >= 0 && gridY < size.Y)
            {
                // Рисуем круг для точки
                handle.DrawCircle(new Vector2(gridX, gridY), 4, Color.Red);
            }
        }
    }

    private Vector2? ClipLineToBounds(Vector2 start, Vector2 end, Vector2 bounds)
    {
        // Алгоритм Коэна-Сазерленда для обрезки линий
        var x1 = start.X;
        var y1 = start.Y;
        var x2 = end.X;
        var y2 = end.Y;

        // Коды областей
        var code1 = GetRegionCode(x1, y1, bounds);
        var code2 = GetRegionCode(x2, y2, bounds);

        var accept = false;

        while (true)
        {
            if ((code1 | code2) == 0)
            {
                // Обе точки внутри - принимаем
                accept = true;
                break;
            }
            else if ((code1 & code2) != 0)
            {
                // Обе точки снаружи в одной области - отбрасываем
                break;
            }
            else
            {
                // Выбираем точку снаружи
                var codeOut = code1 != 0 ? code1 : code2;
                double x, y;

                // Находим точку пересечения
                if ((codeOut & 1) != 0) // Слева
                {
                    x = 0;
                    y = y1 + (y2 - y1) * (0 - x1) / (x2 - x1);
                }
                else if ((codeOut & 2) != 0) // Справа
                {
                    x = bounds.X;
                    y = y1 + (y2 - y1) * (bounds.X - x1) / (x2 - x1);
                }
                else if ((codeOut & 4) != 0) // Снизу
                {
                    y = 0;
                    x = x1 + (x2 - x1) * (0 - y1) / (y2 - y1);
                }
                else // Сверху
                {
                    y = bounds.Y;
                    x = x1 + (x2 - x1) * (bounds.Y - y1) / (y2 - y1);
                }

                // Заменяем внешнюю точку
                if (codeOut == code1)
                {
                    x1 = (float)x;
                    y1 = (float)y;
                    code1 = GetRegionCode(x1, y1, bounds);
                }
                else
                {
                    x2 = (float)x;
                    y2 = (float)y;
                    code2 = GetRegionCode(x2, y2, bounds);
                }
            }
        }

        if (accept)
        {
            return new Vector2((float)x1, (float)y1);
        }

        return null;
    }

    private int GetRegionCode(double x, double y, Vector2 bounds)
    {
        var code = 0;
        if (x < 0) code |= 1;      // Слева
        if (x > bounds.X) code |= 2; // Справа
        if (y < 0) code |= 4;      // Снизу
        if (y > bounds.Y) code |= 8; // Сверху
        return code;
    }

    private void ExtractPointsFromEquation(string equation)
    {
        points.Clear();

        // Ищем координаты в различных форматах
        var patterns = new[]
        {
            @"A\((-?\d+),\s*(-?\d+)\)",
            @"B\((-?\d+),\s*(-?\d+)\)",
            @"точка\s+A\((-?\d+),\s*(-?\d+)\)",
            @"точка\s+B\((-?\d+),\s*(-?\d+)\)",
            @"координаты\s+A\((-?\d+),\s*(-?\d+)\)",
            @"координаты\s+B\((-?\d+),\s*(-?\d+)\)",
            @"точками\s+A\((-?\d+),\s*(-?\d+)\)",
            @"точками\s+B\((-?\d+),\s*(-?\d+)\)"
        };
        var labels = new[] { "A", "B", "A", "B", "A", "B", "A", "B" };

        for (int i = 0; i < patterns.Length; i++)
        {
            var match = Regex.Match(equation, patterns[i]);
            if (match.Success)
            {
                var x = int.Parse(match.Groups[1].Value);
                var y = int.Parse(match.Groups[2].Value);
                points.Add((x, y, labels[i]));
            }
        }
    }
}

public partial class MathConsoleWindow : FancyWindow
{
    private Label CurrentEquationText;
    private LineEdit AnswerInput;
    private Button SubmitButton;
    private Button NewEquationButton;
    private BoxContainer RecordsList;
    private PanelContainer CoordinateGridContainer;
    private CoordinateGridControl CoordinateGrid;
    private Label TotalPointsLabel;

    public event Action<string>? SubmitAnswer;
    public event Action? RequestNewEquation;
    public event Action? OnClose;

    public MathConsoleWindow()
    {
        InitializeComponent();

        CurrentEquationText = this.FindControl<Label>("CurrentEquationText");
        AnswerInput = this.FindControl<LineEdit>("AnswerInput");
        SubmitButton = this.FindControl<Button>("SubmitButton");
        NewEquationButton = this.FindControl<Button>("NewEquationButton");
        RecordsList = this.FindControl<BoxContainer>("RecordsList");
        CoordinateGridContainer = this.FindControl<PanelContainer>("CoordinateGridContainer");
        CoordinateGrid = this.FindControl<CoordinateGridControl>("CoordinateGrid");
        TotalPointsLabel = this.FindControl<Label>("TotalPointsLabel");

        // Привязываем события
        SubmitButton.OnPressed += OnSubmitButtonClick;
        NewEquationButton.OnPressed += OnNewEquationButtonClick;
        AnswerInput.OnTextEntered += OnAnswerInputKeyDown;

        // Фокус на поле ввода
        AnswerInput.GrabKeyboardFocus();
    }

    private void InitializeComponent()
    {
        RobustXamlLoader.Load(this);
    }

    private void OnSubmitButtonClick(BaseButton.ButtonEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void OnNewEquationButtonClick(BaseButton.ButtonEventArgs e)
    {
        RequestNewEquation?.Invoke();
        AnswerInput.Text = string.Empty;
        AnswerInput.GrabKeyboardFocus();
    }

    private void OnAnswerInputKeyDown(LineEdit.LineEditEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void SubmitAnswerInternal()
    {
        var answer = AnswerInput.Text?.Trim();
        if (!string.IsNullOrEmpty(answer))
        {
            SubmitAnswer?.Invoke(answer);
            AnswerInput.Text = string.Empty;
            AnswerInput.GrabKeyboardFocus();
        }
    }

    public void UpdateState(MathConsoleState state)
    {
        CurrentEquationText.Text = state.CurrentEquation;
        TotalPointsLabel.Text = state.TotalPointsEarned.ToString();

        // Проверяем, нужно ли показать координатную сетку
        ShowCoordinateGridIfNeeded(state.CurrentEquation);

        RecordsList.RemoveAllChildren();
        foreach (var record in state.Records.OrderByDescending(r => r.SolvedAt))
        {
            var recordPanel = new PanelContainer();
            recordPanel.PanelOverride = new StyleBoxFlat { BackgroundColor = new Color(0, 0, 0, 0.3f) };

            var recordBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Vertical, Margin = new Thickness(5) };

            // Уравнение
            var equationLabel = new Label
            {
                Text = record.Equation,
                FontColorOverride = Color.White,
                HorizontalExpand = true
            };
            recordBox.AddChild(equationLabel);

            // Ответ и информация
            var infoBox = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal, HorizontalExpand = true };
            infoBox.AddChild(new Label { Text = $"Ответ: {record.Answer}", FontColorOverride = Color.Lime });
            infoBox.AddChild(new Label { Text = $"Игрок: {record.EntityName}", FontColorOverride = Color.Cyan, HorizontalExpand = true });
            infoBox.AddChild(new Label { Text = $"+{record.PointsEarned} очков", FontColorOverride = Color.Yellow });

            recordBox.AddChild(infoBox);
            recordPanel.AddChild(recordBox);

            RecordsList.AddChild(recordPanel);
        }
    }

    private void ShowCoordinateGridIfNeeded(string equation)
    {
        // Показываем координатную сетку для задач с координатной геометрией
        var isCoordinateTask = equation.Contains("точками") ||
                              equation.Contains("расстояние") ||
                              equation.Contains("середину") ||
                              equation.Contains("угловой коэффициент") ||
                              equation.Contains("график") ||
                              equation.Contains("пересечения") ||
                              equation.Contains("окружность") ||
                              equation.Contains("координаты");

        if (isCoordinateTask)
        {
            CoordinateGridContainer.Visible = true;
            CoordinateGrid.SetEquation(equation);
        }
        else
        {
            CoordinateGridContainer.Visible = false;
        }
    }

    public override void Close()
    {
        OnClose?.Invoke();
        base.Close();
    }
}
