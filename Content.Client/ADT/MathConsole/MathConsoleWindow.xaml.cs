using Content.Shared.ADT.MathConsole;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Client.Stylesheets;
using Robust.Client.Graphics;

using System;
using System.Collections.Generic;
using System.Linq;
using Robust.Shared.Input;
using System.Text.RegularExpressions;
using System.Numerics;

namespace Content.Client.ADT.MathConsole;

// Кастомный элемент для отрисовки координатной сетки
public class CoordinateGridControl : Control
{
    private const int GridSize = 21;
    private const int CellSize = 20;
    private List<(int x, int y, string label)> points = new();
    private string currentEquation = "";
    private bool showLines = false;

    public void SetEquation(string equation)
    {
        currentEquation = equation;
        ExtractPointsFromEquation(equation);
        // Показываем линии для задач с двумя точками
        showLines = points.Count == 2;
        InvalidateMeasure();
    }

    public void AddPoint(int x, int y, string label)
    {
        points.Add((x, y, label));
        InvalidateMeasure();
    }

    public void ClearPoints()
    {
        points.Clear();
        InvalidateMeasure();
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        return new Vector2(GridSize * CellSize, GridSize * CellSize);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        var size = Size;
        var centerX = size.X / 2;
        var centerY = size.Y / 2;

        // Рисуем сетку
        for (int i = 0; i <= GridSize; i++)
        {
            var pos = i * CellSize;

            // Вертикальные линии
            if (i == GridSize / 2) // Центральная линия Y
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, size.Y), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(pos, 0), new Vector2(pos, size.Y), Color.Gray);
            }

            // Горизонтальные линии
            if (i == GridSize / 2) // Центральная линия X
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(size.X, pos), Color.Yellow);
            }
            else
            {
                handle.DrawLine(new Vector2(0, pos), new Vector2(size.X, pos), Color.Gray);
            }
        }

        // Рисуем линии между точками (если есть две точки)
        if (showLines && points.Count == 2)
        {
            var point1 = points[0];
            var point2 = points[1];

            var gridX1 = (point1.x + GridSize / 2) * CellSize;
            var gridY1 = (GridSize / 2 - point1.y) * CellSize;
            var gridX2 = (point2.x + GridSize / 2) * CellSize;
            var gridY2 = (GridSize / 2 - point2.y) * CellSize;

            if (gridX1 >= 0 && gridX1 < size.X && gridY1 >= 0 && gridY1 < size.Y &&
                gridX2 >= 0 && gridX2 < size.X && gridY2 >= 0 && gridY2 < size.Y)
            {
                handle.DrawLine(new Vector2(gridX1, gridY1), new Vector2(gridX2, gridY2), Color.Blue);
            }
        }

        // Рисуем точки
        foreach (var point in points)
        {
            // Преобразуем координаты точки в координаты экрана
            // Центр сетки находится в (GridSize/2, GridSize/2)
            var gridX = (point.x + GridSize / 2) * CellSize;
            var gridY = (GridSize / 2 - point.y) * CellSize; // Инвертируем Y для правильной ориентации

            if (gridX >= 0 && gridX < size.X && gridY >= 0 && gridY < size.Y)
            {
                // Рисуем круг для точки
                handle.DrawCircle(new Vector2(gridX, gridY), 4, Color.Red);
            }
        }


    }

    private void ExtractPointsFromEquation(string equation)
    {
        points.Clear();

                // Ищем координаты в различных форматах
        var patterns = new[]
        {
            @"A\((-?\d+),\s*(-?\d+)\)",
            @"B\((-?\d+),\s*(-?\d+)\)",
            @"точка\s+A\((-?\d+),\s*(-?\d+)\)",
            @"точка\s+B\((-?\d+),\s*(-?\d+)\)",
            @"координаты\s+A\((-?\d+),\s*(-?\d+)\)",
            @"координаты\s+B\((-?\d+),\s*(-?\d+)\)",
            @"точками\s+A\((-?\d+),\s*(-?\d+)\)",
            @"точками\s+B\((-?\d+),\s*(-?\d+)\)"
        };
        var labels = new[] { "A", "B", "A", "B", "A", "B", "A", "B" };

        for (int i = 0; i < patterns.Length; i++)
        {
            var match = Regex.Match(equation, patterns[i]);
            if (match.Success)
            {
                var x = int.Parse(match.Groups[1].Value);
                var y = int.Parse(match.Groups[2].Value);
                points.Add((x, y, labels[i]));
            }
        }
    }
}

public partial class MathConsoleWindow : DefaultWindow
{
    private Label CurrentEquationText;
    private LineEdit AnswerInput;
    private Button SubmitButton;
    private Button NewEquationButton;
    private BoxContainer RecordsList;
    private PanelContainer CoordinateGridContainer;
    private CoordinateGridControl CoordinateGrid;

    public event Action<string>? SubmitAnswer;
    public event Action? RequestNewEquation;
    public event Action? OnClose;

    public MathConsoleWindow()
    {
        InitializeComponent();

        CurrentEquationText = this.FindControl<Label>("CurrentEquationText");
        AnswerInput = this.FindControl<LineEdit>("AnswerInput");
        SubmitButton = this.FindControl<Button>("SubmitButton");
        NewEquationButton = this.FindControl<Button>("NewEquationButton");
        RecordsList = this.FindControl<BoxContainer>("RecordsList");
        CoordinateGridContainer = this.FindControl<PanelContainer>("CoordinateGridContainer");
        CoordinateGrid = this.FindControl<CoordinateGridControl>("CoordinateGrid");

        // Привязываем события
        SubmitButton.OnPressed += OnSubmitButtonClick;
        NewEquationButton.OnPressed += OnNewEquationButtonClick;
        AnswerInput.OnTextEntered += OnAnswerInputKeyDown;

        // Фокус на поле ввода
        AnswerInput.GrabKeyboardFocus();
    }

    private void InitializeComponent()
    {
        RobustXamlLoader.Load(this);
    }

    private void OnSubmitButtonClick(BaseButton.ButtonEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void OnNewEquationButtonClick(BaseButton.ButtonEventArgs e)
    {
        RequestNewEquation?.Invoke();
        AnswerInput.Text = string.Empty;
        AnswerInput.GrabKeyboardFocus();
    }

    private void OnAnswerInputKeyDown(LineEdit.LineEditEventArgs e)
    {
        SubmitAnswerInternal();
    }

    private void SubmitAnswerInternal()
    {
        var answer = AnswerInput.Text?.Trim();
        if (!string.IsNullOrEmpty(answer))
        {
            SubmitAnswer?.Invoke(answer);
            AnswerInput.Text = string.Empty;
            AnswerInput.GrabKeyboardFocus();
        }
    }

    public void UpdateState(MathConsoleState state)
    {
        CurrentEquationText.Text = state.CurrentEquation;

        // Проверяем, нужно ли показать координатную сетку
        ShowCoordinateGridIfNeeded(state.CurrentEquation);

        RecordsList.RemoveAllChildren();
        foreach (var record in state.Records.OrderByDescending(r => r.SolvedAt))
        {
            var recordPanel = new BoxContainer { Orientation = BoxContainer.LayoutOrientation.Horizontal };
            recordPanel.AddChild(new Label { Text = record.Equation });
            recordPanel.AddChild(new Label { Text = record.Answer });
            recordPanel.AddChild(new Label { Text = record.EntityName });
            RecordsList.AddChild(recordPanel);
        }
    }

    private void ShowCoordinateGridIfNeeded(string equation)
    {
        // Показываем координатную сетку для задач с координатной геометрией
        var isCoordinateTask = equation.Contains("точками") ||
                              equation.Contains("расстояние") ||
                              equation.Contains("середину") ||
                              equation.Contains("угловой коэффициент") ||
                              equation.Contains("график") ||
                              equation.Contains("пересечения") ||
                              equation.Contains("окружность") ||
                              equation.Contains("координаты");

        if (isCoordinateTask)
        {
            CoordinateGridContainer.Visible = true;
            CoordinateGrid.SetEquation(equation);
        }
        else
        {
            CoordinateGridContainer.Visible = false;
        }
    }



    public override void Close()
    {
        OnClose?.Invoke();
        base.Close();
    }
}
